# Lesson 5 — Qdrant Schema & Vectorization  


---

## Learning Objectives

By the end of this lesson, you will be able to:

- Explain what a **Qdrant schema** is and why it exists.
- Explain **embeddings** in beginner-friendly language.
- Verify Qdrant and the vectorizer are healthy from inside Docker.
- Safely extend a schema with a new field.
- Rebuild and validate ingestion without breaking retrieval.
- Understand why schema changes must be controlled in production systems.

---

# Step 1 — Mental Model: What’s Actually Happening

Qdrant stores two things:

- **Objects (Payloads)** → Your structured documents (JSON)
- **Vectors** → Numeric embeddings representing semantic meaning

Unlike Weaviate, Qdrant does **not** automatically vectorize text.

In this lab, the **Ingestion API generates embeddings locally** using a SentenceTransformer model. Those vectors are then stored in Qdrant alongside the document payload.

That vector enables **semantic search**.

Instead of matching keywords, Qdrant retrieves documents based on meaning by comparing vector similarity.

---

### System Flow

User → Edge (NGINX) → Ingestion API → Qdrant  
                                          ↳ Embedding Model (inside API)

---

> In production systems, embeddings are often generated by a separate model service.  
> In this lab, embeddings are generated directly inside the ingestion API to simplify deployment and improve compatibility across systems.
---

# Step 2 — Verify Internal Readiness

We do NOT expose Qdrant to localhost.  
Everything runs inside Docker’s internal network.

---

## 2.1 Check Qdrant Readiness

```bash
docker exec -i ingestion-api python - <<'PY'
import urllib.request
print(urllib.request.urlopen("http://qdrant:6333/healthz").read().decode())
PY
```

### Expected Output

```text
healthz check passed
```

---

If the test fails:

```bash
docker compose logs qdrant --tail=200
```

---

## Step 3 --- Guided Payload Extension

Real-world datasets require metadata for:

-   Filtering
-   Categorization
-   Governance
-   Analytics

In this step, we extend the system safely.

------------------------------------------------------------------------

## Architectural Reminder (Example: Qdrant vs Weaviate)

Qdrant does **not** use a strict database property schema like Weaviate.

Qdrant stores:

-   **Vectors** → Numeric embeddings for semantic similarity
-   **Payload** → Your full JSON document

Because of this:

-   There is **no database schema migration required**
-   We only update the **API validation model**
-   Qdrant automatically stores new fields in the payload

This is a key architectural difference from the Weaviate lab.

------------------------------------------------------------------------

# Step 3.1 --- Update the API Request Model (`schemas.py`)

Your API schema defines what data is valid.

If you do not update this file, ingestion will reject requests
containing `tags`.

Open:

    ingestion-api/app/schemas.py
    
## Open the File with Nano

From the root of your project directory, run:

```bash
nano ingestion-api/app/schemas.py
```

### Modify the Model

Update the `ArticleIn` model:

``` python
class ArticleIn(BaseModel):
    title: str
    url: str
    source: str
    published_date: str
    text: str
    tags: list[str] = []
```

Save the file.

Press Ctrl + O to save changes.
Press Enter to confirm the filename.
Press Ctrl + X to exit Nano.

------------------------------------------------------------------------

## Why This Matters

-   `list[str]` accepts an array of strings
-   The default `[]` prevents validation errors
-   The API model controls ingestion safety
-   Qdrant stores whatever JSON payload you send

You have now extended the API contract safely.

------------------------------------------------------------------------

# Step 3.2 --- Qdrant Storage (No Schema Migration Required)

Unlike Weaviate:

-   There is no `properties` list
-   There is no `text[]` datatype
-   There is no database schema update

When you ingest a document containing:

``` json
"tags": ["lab2", "schema-change"]
```

Qdrant stores it automatically inside the payload.

No migration is required.

> Important: Tags are stored as metadata only. They do not affect
> semantic retrieval unless you implement filtering logic.

------------------------------------------------------------------------

# Optional --- Create a Payload Index for `tags`

If you plan to filter by tags later, create a payload index.

``` bash
QDRANT_COLLECTION=$(grep -E '^QDRANT_COLLECTION=' .env | cut -d= -f2-)

curl -X PUT "http://localhost:6333/collections/${QDRANT_COLLECTION}/index"   -H "Content-Type: application/json"   -d '{
    "field_name": "tags",
    "field_schema": "keyword"
  }'
```

If this command returns an error, you may safely skip it. Tags will
still be stored correctly.

------------------------------------------------------------------------

# Step 3.3 --- Update Sample Data

Open:

    data/sample_articles.jsonl
    
## Open the File with Nano

From the root of your project directory, run:

```bash
nano data/sample_articles.jsonl
```

Modify one entry to include tags:

``` json
{"title":"Example","url":"https://example.com","source":"Manual","published_date":"2026-02-13","text":"Sample text for schema testing.","tags":["lab2","schema-change"]}
```

Save the file.
Press Ctrl + O to save changes.
Press Enter to confirm the filename.
Press Ctrl + X to exit Nano.

------------------------------------------------------------------------

# Step 3.4 --- Rebuild the API

Because you modified Python code:

``` bash
docker compose up -d --build ingestion-api
```

Wait for:

    Application startup complete.

------------------------------------------------------------------------

# Step 3.5 --- Re-Run Ingestion

``` bash
EDGE_API_KEY=$(grep -E '^EDGE_API_KEY=' .env | cut -d= -f2-)

curl -i -X POST "http://localhost:8088/ingest"   -H "Content-Type: application/json"   -H "X-API-Key: $EDGE_API_KEY"   -d '{
    "title": "Tagged Doc",
    "url": "https://example.com/tagged",
    "source": "Manual",
    "published_date": "2026-02-13",
    "tags": ["lab2", "schema-change"],
    "text": "This document proves schema changes can be applied safely."
  }'
```

Expected output:

``` json
{
  "status": "ok",
  "qdrant": {
    "result": "upserted",
    "id": "..."
  }
}
```

------------------------------------------------------------------------

# Step 3.6 --- Verify Retrieval Still Works

``` bash
curl -sS -G "http://localhost:8088/debug/retrieve"   -H "X-API-Key: $EDGE_API_KEY"   --data-urlencode "q=schema changes applied safely" | python -m json.tool
```

------------------------------------------------------------------------

# Checkpoints

You have:

-   Extended the API validation model safely
-   Updated sample data
-   Rebuilt containers correctly
-   Re-ingested updated documents
-   Confirmed semantic retrieval still works

------------------------------------------------------------------------

# Why This Matters

In production systems:

-   API contracts must stay aligned with stored data
-   Schema changes must be versioned
-   Rebuilds must be controlled
-   Retrieval must be revalidated after changes
-   
------------------------------------------------------------------------

[Lesson 6](https://github.com/JacksonHolmes01/Training-Module-Production-Grade-RAG-Infrastructure-Qdrant/blob/main/lessons/06-ingestion-api-validation-and-ingest.md)
